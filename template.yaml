# AWS SAM template for fishing data pipeline

# CloudFormationテンプレートのバージョン（固定値）
AWSTemplateFormatVersion: '2010-09-09'
# AWS SAMのマクロを有効化（Serverlessアプリケーション用の拡張機能）
Transform: AWS::Serverless-2016-10-31
# このテンプレートの説明
Description: Fishing data pipeline (AppSync -> S3/DDB -> SES)

# 全Lambda関数に共通で適用される設定
Globals:
  Function:
    # Python 3.12ランタイムを使用
    Runtime: python3.12
    # 関数のタイムアウト時間（秒）
    Timeout: 60
    # 関数に割り当てるメモリサイズ（MB）
    MemorySize: 512
    # AWS X-Rayトレーシングを有効化（デバッグ・監視用）
    Tracing: Active
    # 全関数で共通の環境変数
    Environment:
      Variables:
        # AppSync GraphQL APIのエンドポイントURL
        APPSYNC_URL: "https://iqqdsybr6beovaix6btxwykuha.appsync-api.ap-northeast-1.amazonaws.com/graphql"
        # デフォルトの施設名
        FACILITY_DEFAULT: "honmoku"

# デプロイ時に指定するパラメータ（sam deploy時に値を渡す）
Parameters:
  # AppSync APIの認証キー（初回デプロイ時のみ使用）
  # シークレットは一度作成されれば、その後はAWSコンソールやCLIで更新可能
  AppSyncApiKey:
    Type: String
    NoEcho: true  # デプロイ時に値を入力しても画面に表示されない
    Description: "AppSync GraphQL APIの認証キー（初回デプロイ時のみ必要）"
  # SES（Simple Email Service）の送信元メールアドレス
  SesFrom:
    Type: String
  # SESの送信先メールアドレス
  SesTo:
    Type: String
  # API用のカスタムドメイン名（例: api.example.com）
  ApiDomainName:
    Type: String
    Default: ""
    Description: "API用のカスタムドメイン名（空文字列の場合はカスタムドメインを設定しない）"
  # Route53のホストゾーンID（カスタムドメインを使用する場合に必要）
  HostedZoneId:
    Type: String
    Default: ""
    Description: "Route53のホストゾーンID（カスタムドメインを使用する場合に必要）"
  # ACM証明書のARN（手動で作成した証明書のARNを指定）
  CertificateArn:
    Type: String
    Default: ""
    Description: "ACM証明書のARN（カスタムドメインを使用する場合に必要）"
  CorsAllowOrigin:
    Type: String
    Default: "*"
    Description: "CORSのAllowOrigin 本番は自ドメインに絞る"

# 作成するAWSリソースの定義
Resources:
  # AppSync APIキーを保存するSecrets Managerシークレット
  # 初回デプロイ時に作成され、その後はAWSコンソールやCLIで更新可能
  AppSyncApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      # シークレット名（スタック名を含めて一意にする）
      # 形式: {スタック名}/appsync-api-key
      Name: !Sub "${AWS::StackName}/appsync-api-key"
      Description: "AppSync GraphQL APIの認証キー"
      # シークレットの値（JSON形式で保存）
      # 初回デプロイ時のみ使用され、その後は手動で更新
      SecretString: !Sub |
        {
          "apiKey": "${AppSyncApiKey}"
        }

  # 生データを保存するS3バケット
  RawBucket:
    Type: AWS::S3::Bucket
    Properties:
      # S3バケット名はグローバルで一意である必要があるため、
      # スタック名、アカウントIDを含めて命名
      # 形式: raw-{スタック名}-{アカウントID}
      # 
      # AWS::StackName: CloudFormationの組み込み疑似パラメータ（自動提供される値）
      #   - sam deploy時に--stack-nameオプションで指定、またはsamconfig.tomlで設定
      #   - 例: "honmoku-stats-dev" のようにプロジェクト名と環境名を含めることを推奨
      # AWS::AccountId: 現在のAWSアカウントID（自動的に取得される）
      BucketName: !Sub "raw-${AWS::StackName}-${AWS::AccountId}"

  # 日次統計データを保存するDynamoDBテーブル
  FishingDailyTable:
    Type: AWS::DynamoDB::Table
    Properties:
      # テーブル名を明示的に指定（リージョン内で一意である必要がある）
      # 複数環境（dev/staging/prod）を同じリージョンにデプロイする場合の衝突を防ぐため、
      # スタック名を含めて命名
      # 形式: {スタック名}-fishing-daily
      TableName: !Sub "${AWS::StackName}-fishing-daily"
      # オンデマンド課金モード（使用量に応じて自動スケール）
      BillingMode: PAY_PER_REQUEST
      # テーブルの属性（カラム）定義
      AttributeDefinitions:
        - AttributeName: PK  # Partition Key（パーティションキー）
          AttributeType: S    # String型
        - AttributeName: SK  # Sort Key（ソートキー）
          AttributeType: S    # String型
      # テーブルのキー構成
      KeySchema:
        - AttributeName: PK
          KeyType: HASH   # パーティションキー（データの分散に使用）
        - AttributeName: SK
          KeyType: RANGE  # ソートキー（同一パーティション内での並び順を決定）

  # 釣果データを保存するDynamoDBテーブル
  FishingCatchTable:
    Type: AWS::DynamoDB::Table
    Properties:
      # テーブル名を明示的に指定（リージョン内で一意である必要がある）
      # 複数環境（dev/staging/prod）を同じリージョンにデプロイする場合の衝突を防ぐため、
      # スタック名を含めて命名
      # 形式: {スタック名}-fishing-catch
      TableName: !Sub "${AWS::StackName}-fishing-catch"
      # オンデマンド課金モード（使用量に応じて自動スケール）
      BillingMode: PAY_PER_REQUEST
      # テーブルの属性（カラム）定義
      AttributeDefinitions:
        - AttributeName: PK  # Partition Key（パーティションキー）
          AttributeType: S    # String型
        - AttributeName: SK  # Sort Key（ソートキー）
          AttributeType: S    # String型
      # テーブルのキー構成
      KeySchema:
        - AttributeName: PK
          KeyType: HASH   # パーティションキー（データの分散に使用）
        - AttributeName: SK
          KeyType: RANGE  # ソートキー（同一パーティション内での並び順を決定）

  # ---- Phase0: Fetcher ----
  # AppSyncからデータを取得してS3/DynamoDBに保存するLambda関数
  FetchFunction:
    Type: AWS::Serverless::Function
    Properties:
      # 関数名を明示的に指定（リージョン内で一意である必要がある）
      # 複数環境を同じリージョンにデプロイする場合の衝突を防ぐため、
      # スタック名を含めて命名
      # 形式: {スタック名}-fetch
      FunctionName: !Sub "${AWS::StackName}-fetch"
      # 関数のソースコードが配置されているディレクトリ
      CodeUri: src/
      # エントリーポイント（モジュール名.関数名）
      Handler: fetcher.lambda_handler
      # この関数に付与するIAMポリシー（アクセス権限）
      Policies:
        # S3バケットへの書き込み権限
        - S3WritePolicy:
            BucketName: !Ref RawBucket  # !Ref: 他のリソースを参照
        # DynamoDBテーブルへの読み書き権限
        - DynamoDBCrudPolicy:
            TableName: !Ref FishingDailyTable
        - DynamoDBCrudPolicy:
            TableName: !Ref FishingCatchTable
        # SES（メール送信サービス）への送信権限
        - Statement:
            - Effect: Allow
              Action:
                - ses:SendEmail
                - ses:SendRawEmail
              Resource: "*"
        # Secrets Managerからシークレットを読み取る権限
        - Statement:
            - Effect: Allow
              Action:
                - secretsmanager:GetSecretValue
                - secretsmanager:DescribeSecret
              Resource: !Ref AppSyncApiKeySecret
      # この関数専用の環境変数（Globalsの設定を上書き・追加）
      Environment:
        Variables:
          # AppSync APIキーのシークレットARN（Lambda関数内でboto3を使って取得）
          # シークレットはJSON形式で保存され、apiKeyキーから値を取得する
          APPSYNC_API_KEY_SECRET_ID: !Ref AppSyncApiKeySecret
          S3_BUCKET: !Ref RawBucket
          DDB_DAILY_TABLE: !Ref FishingDailyTable
          DDB_CATCH_TABLE: !Ref FishingCatchTable
          SES_FROM: !Ref SesFrom
          SES_TO: !Ref SesTo
          # テスト用: 指定した日付のデータを取得する場合は値を設定（形式: YYYY-MM-DD）。空文字列の場合は前日を取得
          TARGET_DATE: ""
          # バッチ処理用: 日付レンジを指定する場合はSTART_DATEとEND_DATEの両方を設定（形式: YYYY-MM-DD）
          # 通常の定期実行では設定不要（未定義のままでOK）
          # START_DATE: ""
          # END_DATE: ""


  # EventBridge Scheduler: Lambda関数を定期実行するスケジュール
  DailySchedule:
    Type: AWS::Scheduler::Schedule
    Properties:
      # スケジュール名を明示的に指定（リージョン内で一意である必要がある）
      # 複数環境を同じリージョンにデプロイする場合の衝突を防ぐため、
      # スタック名を含めて命名
      # 形式: {スタック名}-daily-schedule
      Name: !Sub "${AWS::StackName}-daily-schedule"
      # 時間の柔軟性なし（指定時刻に厳密に実行）
      FlexibleTimeWindow:
        Mode: "OFF"
      # Cron式でスケジュールを定義（UTC時刻）
      # JST 06:30 = UTC 21:30（前日）
      # 形式: cron(分 時 日 月 曜年)
      ScheduleExpression: "cron(30 21 * * ? *)"
      # 実行対象のLambda関数
      Target:
        Arn: !GetAtt FetchFunction.Arn  # !GetAtt: リソースの属性を取得
        # Lambda関数を呼び出すためのIAMロール
        RoleArn: !GetAtt SchedulerInvokeRole.Arn


  # DailySchedule（Scheduler）からFetchFunctionをInvokeできるようにするLambda Permission
  FetchFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref FetchFunction
      Principal: scheduler.amazonaws.com
      SourceArn: !GetAtt DailySchedule.Arn

  # EventBridge SchedulerがLambda関数を呼び出すためのIAMロール
  SchedulerInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      # ロール名はCloudFormationが自動生成（{StackName}-{LogicalId}-{RandomSuffix}形式）
      # スタック名が含まれるため識別可能で、名前の衝突も避けられる
      # このロールを引き受けられるサービスを定義
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: scheduler.amazonaws.com  # EventBridge Schedulerサービス
            Action: sts:AssumeRole
      # このロールに付与する権限
      Policies:
        - PolicyName: InvokeLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction  # Lambda関数の実行権限
                Resource: !GetAtt FetchFunction.Arn

  # ---- Phase1: API ----
  # API Gateway (HTTP API)の定義
  FishingApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      # API名を明示的に指定
      Name: !Sub "${AWS::StackName}-api"
      # 認証設定: 認証なしでパブリックアクセスを許可
      # 外部から直接呼び出し可能にする
      # Authセクションを省略することで認証なしを指定
      # デフォルトステージを明示的に指定（ApiDomainMappingで参照するため）
      StageName: "$default"
      # CORS設定（必要に応じて調整）
      CorsConfiguration:
        AllowOrigins:
          - !Ref CorsAllowOrigin
        AllowMethods:
          - GET
          - OPTIONS
        AllowHeaders:
          - "*"
        MaxAge: 300
      # アクセスログ設定（CloudWatch Logsに出力）
      AccessLogSettings:
        DestinationArn: !GetAtt ApiAccessLogGroup.Arn
        Format: |
          {
            "requestId": "$context.requestId",
            "ip": "$context.identity.sourceIp",
            "requestTime": "$context.requestTime",
            "httpMethod": "$context.httpMethod",
            "routeKey": "$context.routeKey",
            "status": $context.status,
            "protocol": "$context.protocol",
            "responseLength": $context.responseLength,
            "userAgent": "$context.identity.userAgent",
            "path": "$context.path",
            "requestTimeEpoch": $context.requestTimeEpoch,
            "integrationRequestId": "$context.integration.requestId",
            "integrationStatus": "$context.integration.status",
            "integrationLatency": "$context.integration.latency",
            "integrationServiceStatus": "$context.integration.integrationStatus"
          }

  # API Gatewayのアクセスログ用CloudWatch Logsロググループ
  ApiAccessLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/apigateway/${AWS::StackName}-api-access"
      RetentionInDays: 30  # ログの保持期間（日数）。必要に応じて調整

  # API Gatewayがロググループに書き込むためのリソースポリシー
  ApiAccessLogGroupPolicy:
    Type: AWS::Logs::ResourcePolicy
    Properties:
      PolicyName: !Sub "${AWS::StackName}-api-access-log-policy"
      PolicyDocument: !Sub |
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "apigateway.amazonaws.com"
              },
              "Action": [
                "logs:CreateLogStream",
                "logs:PutLogEvents"
              ],
              "Resource": "${ApiAccessLogGroup.Arn}:*"
            }
          ]
        }

  # DynamoDBからデータを取得してAPIとして提供するLambda関数
  ApiFunction:
    Type: AWS::Serverless::Function
    Properties:
      # 関数名を明示的に指定（リージョン内で一意である必要がある）
      # 複数環境を同じリージョンにデプロイする場合の衝突を防ぐため、
      # スタック名を含めて命名
      # 形式: {スタック名}-api
      FunctionName: !Sub "${AWS::StackName}-api"
      # 関数のソースコードが配置されているディレクトリ
      CodeUri: src/
      # エントリーポイント（モジュール名.関数名）
      Handler: app.lambda_handler
      # この関数に付与するIAMポリシー（アクセス権限）
      Policies:
        # DynamoDBテーブルへの読み取り権限
        - DynamoDBReadPolicy:
            TableName: !Ref FishingDailyTable
        - DynamoDBReadPolicy:
            TableName: !Ref FishingCatchTable
      # この関数専用の環境変数（Globalsの設定を上書き・追加）
      Environment:
        Variables:
          DDB_DAILY_TABLE: !Ref FishingDailyTable
          DDB_CATCH_TABLE: !Ref FishingCatchTable
      # API Gatewayのイベント定義
      Events:
        # すべてのHTTPリクエストをこのLambda関数にルーティング
        # app.pyのlambda_handlerが内部でパスに基づいてルーティングを処理
        ApiEvent:
          Type: HttpApi
          Properties:
            ApiId: !Ref FishingApi
            Path: /{proxy+}
            Method: ANY
        # ルートパス（/）も処理できるようにする
        RootApiEvent:
          Type: HttpApi
          Properties:
            ApiId: !Ref FishingApi
            Path: /
            Method: ANY

  # ---- Phase1: Custom Domain ----
  # API Gateway用のカスタムドメイン（条件付きで作成）
  # 注意: ドメイン、証明書、Route53レコードは手動で作成してください
  ApiCustomDomain:
    Type: AWS::ApiGatewayV2::DomainName
    Condition: UseCustomDomain
    Properties:
      DomainName: !Ref ApiDomainName
      DomainNameConfigurations:
        - CertificateArn: !Ref CertificateArn
          EndpointType: REGIONAL
          SecurityPolicy: TLS_1_2

  # API GatewayのカスタムドメインとHTTP APIのマッピング
  # 注意: FishingApiとそのステージが作成されるのを待つ必要があるため、DependsOnでFishingApiを指定
  ApiDomainMapping:
    Type: AWS::ApiGatewayV2::ApiMapping
    Condition: UseCustomDomain
    DependsOn:
      - ApiCustomDomain
      - FishingApiApiGatewayDefaultStage
    Properties:
      ApiId: !Ref FishingApi
      DomainName: !Ref ApiCustomDomain
      Stage: "$default"

# 条件定義
Conditions:
  # カスタムドメイン名が指定されているか
  HasCustomDomain: !Not [!Equals [!Ref ApiDomainName, ""]]
  HasCertificateArn: !Not [!Equals [!Ref CertificateArn, ""]]
  UseCustomDomain: !And [!Condition HasCustomDomain, !Condition HasCertificateArn]

# デプロイ後に参照できる出力値
Outputs:
  # API GatewayのエンドポイントURL（デフォルト）
  ApiEndpoint:
    Description: "API GatewayのエンドポイントURL（デフォルト）"
    Value: !GetAtt FishingApi.ApiEndpoint
    # Export:
    #   Name: !Sub "${AWS::StackName}-ApiEndpoint"
  # カスタムドメインのエンドポイントURL（カスタムドメインが設定されている場合）
  ApiCustomDomainEndpoint:
    Condition: HasCustomDomain
    Description: "カスタムドメインのエンドポイントURL"
    Value: !Sub "https://${ApiDomainName}"
    # Export:
    #   Name: !Sub "${AWS::StackName}-ApiCustomDomainEndpoint"
  # APIのエンドポイント例（使用例を表示）
  ApiExampleSeries:
    Description: "時系列データ取得APIのエンドポイント例"
    Value: !If
      - HasCustomDomain
      - !Sub "https://${ApiDomainName}/v1/series?fish=クロダイ&facility=honmoku"
      - !Sub "${FishingApi.ApiEndpoint}/v1/series?fish=クロダイ&facility=honmoku"

  ApiExampleDay:
    Description: "日次データ取得APIのエンドポイント例"
    Value: !If
      - HasCustomDomain
      - !Sub "https://${ApiDomainName}/v1/day?date=2024-01-15&facility=honmoku"
      - !Sub "${FishingApi.ApiEndpoint}/v1/day?date=2024-01-15&facility=honmoku"
